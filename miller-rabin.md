### Miller-Rabin素数测试

###### Format素数判断法

费马小定理：当$p$为质数的时候，对于任意的$a$满足$gcd(a,p)=1$一定有$a^{p-1} \equiv 1(\bmod p)$。

如果在这两边同时乘上一个$a$也可以变成 对于任意的$a$一定有$a^{p}\equiv a(\bmod p)$

这个东西的证明可以用数学归纳法，二项式展开然后取模，很简单。

如果这个定理的逆命题成立，也就是说$a^{p-1} \equiv 1(\bmod p)$时一定能推出$p$是质数，那就只需要一个$logn$级别的快速幂就可以判断质数了，岂不是很舒服？

但是可惜的是这个逆命题并不成立，反例有很多，比如说取$a=2$时$2^{341} \equiv 2(\bmod 341)$，但是$341=11 \times 13$，并不是一个质数。我们把这种数字称作伪素数。

如果换用不同的$a$，比如取$a=3$时$3^{341}\equiv 168(\bmod341)$就可以通过$341$这个伪素数。如果随机选取多个$a$，确实能够降低算法出错的概率。但是还有这样的一种数字$n$：$n$是一个合数，但是对于所有满足$gcd(a,n)=1$的$a$都有$a^{p}\equiv a(\bmod p)$成立。这样的数字被称为卡迈尔数，比如$561=3\times11\times17$就是一个卡迈尔数。

对于卡迈尔数，无论随机选取多少个a都是无济于事的，所以Format素数判断法存在缺陷，需要引入一个新的定理。

下面给出一份$format$算法的参考代码（测试次数为5次）

```c++
bool format(int x)
{
    if(x == 2) return 1;
    int test_case = 5;
    while(test_case--)
    {
        int a = rand() % (x - 2) + 2;
        if(ksm(a, x, x) != a) return 0;//ksm是快速幂
    }
    return 1;
}
```



###### 二次探测定理

二次探测定理的内容很简单：如果$ p$ 是一个素数，$0<a<p$, 则方程 $a^{2}\equiv 1(\bmod p) $的解为$ a = 1$ 或 $a = p - 1$。

该定理的证明更简单：$a^{2}\equiv 1(\bmod p) $两边减去$1$，再用平方差公式因式分解得到$(a-1)(a+1)\equiv0(\bmod p)$。这样$p$就是$(a+1)(a-1)$的约数，即$kp=(a+1)(a-1)$。由于$p$是质数，所以$(a-1)$，$(a+1)$之中一定有一个是$p$的倍数，也就是$ a = 1$ 或 $a = p - 1$。并且该同余方程不可能有其他的解。

根据二次探测定理来判断质数，我们只需要取一个$a\neq1$且$a\neq p-1$判断一下${a^2}\equiv1(\bmod p)$是否成立就可以了，如果等式成立了说明$p$是个合数。但是问题是，如果等式不成立，却不能说明$p$是不是质数。所以Miller和Rabin两个人把这两个定理用在了同一个算法中进行质数判断，这个算法就是准确率极高的Miller-Rabin算法。

###### Miller-Rabin算法

设我们待测的数字是$x$，如果$x$是偶数那直接可以判断，下面讨论$x$是奇数的情况。

第一步，将$x-1$不断地除以$2$直到不能除，可以求解出等式$x-1=2^{s}\times u$中的$s$和$u$。

第二步，任意选取一个较小的质数$a$，求出$a^{u} \bmod x$，记作$A_0$。

第三步，将$A_0$平方得到$A_1$，根据二次探测定理，如果$A_0\neq1$且$A_0\neq{x-1}$的情况下，却出现了$A_1\equiv 1(\bmod x)$，那就说明$x$一定是一个合数，否则继续测试。

第四步，不断地对$A_i$平方求出$A_{i+1}$，使用和第三步一样的办法判断$x$有没有可能是合数，如果是合数也就不用再测了。

第五步，不断平方之后最后一定会求出一个$A_k\equiv a^{x-1}(\bmod x)$，这时候判断一下$A_k$是不是$1$就行了。根据费马小定理，如果不是$1$，说明$x$是合数；否则，则$x$有很大概率为质数。

每次判断只选取了一个$a$作为判断的基数，这样算法的出错概率依然存在。比如取$a=2$时$2047$就能通过所有测试，但是它是个合数，这样的数字被称为强伪素数。所以一般我们会选取多个$a$，重复以上判断的流程，可以大大加强算法的准确性。例如取$a=2,3,5,7$时，$int$范围内的所有正整数都可以被正确地判断出来。（不知道哪里看的结论，说$x$每通过一次测试，则$x$不是素数的概率为$25\%$，经过$t$轮测试后$x$不是素数的概率是$\frac{1}{4^{t}}$）

最后上一份代码（实现比较丑）

```c++
bool miller_rabin(int x)
{
    //特判：偶数和2,3,5,7
    if(!(x & 1)) return x == 2;
    int a[] = {2, 3, 5, 7};
    for(int i = 0; i < 4; i++)
    if(a[i] == x) return 1;
    
    //判断是不是质数
    int u = x - 1;
    while(!(u & 1)) u >>= 1;
    for(int i = 0;i < 4; i++)
    {
        //设置平方的终点，顺便利用费马小先筛一次
        int pownum = ksm(a[i], x - 1, x);
        if(pownum != 1) return 0;
        //设置平方的起点a0，即a^u
        int a0 = ksm(a[i], u, x);
        while(a0 != pownum)
        {
            int a1 = ((ll)a0 * a0) % x;//进行平方，a1是平方之后的数
            if(a0 != 1 && a0 != x - 1 && a1 == 1) return 0;
            a0 = a1;
        }
    }
    return 1;
}
```



